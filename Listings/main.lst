C51 COMPILER V9.54   MAIN                                                                  09/21/2022 10:50:01 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\filegame\keil\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          
   2          #include "reg52.h"
   3          #include "intrins.h"
   4          /********以下为参数与环境变量区********/
   5          unsigned int path;                                      //红外对管反馈的环境变量
   6          unsigned int pow;                                       //电机驱动力度的调节
   7          unsigned int i=0;                                       //轨道丢失参数(当轨道丢失到一定的时间后启动倒车程序)
   8          sbit  Car_Servo=P2^0;               // 舵机pwm控制
   9          
  10          unsigned int Servo0PwmDuty=1500;        //PWM脉冲宽度   1.5ms脉冲宽度  为舵机正中位置
  11          
  12          /***********************************************************
  13          * 名    称：InitTimer0()
  14          * 功    能：舵机时钟0初始化
  15          * 入口参数：无
  16          * 出口参数：无
  17          * 说    明：12M晶振，12分频，所以计数器每递增一个数就是1微秒，完全满足舵机
             -制的精度要求
  18                                  因为定时器是TH0，TL0都要全部计数到0xFF后在计1个数就会产生中断，所以要想
             -生
  19                                  x毫秒的中断，那么TH0，TL0就应该赋值（0xFFFF-x） 从这个值开始计数产生定时中
             -断
  20          /**********************************************************/
  21          void InitTimer0(void)           //20ms
  22          {
  23   1          TMOD &= 0xF0;               //设置定时器模式
  24   1          TMOD |= 0x01;               //设置定时器模式
  25   1          TL0 = 0xE0;                 //设置定时初值
  26   1          TH0 = 0xB1;                 //设置定时初值
  27   1          TF0 = 0;                    //清除TF0标志
  28   1          TR0 = 1;                    //定时器0开始计时
  29   1          ET0 = 1;                    //开定时器0中断
  30   1          EA = 1;             //开总中断
  31   1      }
  32          void Car_Servo_Init()   //舵机初始化
  33          {
  34   1          InitTimer0();
  35   1      }
  36          
  37          /***********************************************************
  38          * 名    称：Timer0Value(uint16 pwm)
  39          * 功    能：给定时器0计数器赋值产生定时中断
  40          * 入口参数：pwm            控制舵机的PWM脉冲宽度值（范围：500~2500）
  41          * 出口参数：无
  42          * 说    明：12M晶振，12分频，所以计数器每递增一个数就是1微秒，完全满足舵机
             -制的精度要求
  43                                  因为定时器是TH0，TL0都要全部计数到0xFF后在计1个数就会产生中断，所以要想
             -生
  44                                  pwm毫秒的中断，那么TH0，TL0就应该赋值（0xFFFF-pwm）     从这个值开始计数产生定
             -中断
  45          /**********************************************************/
  46          void Timer0Value(unsigned int pwm)
  47          {
  48   1          unsigned int value;
C51 COMPILER V9.54   MAIN                                                                  09/21/2022 10:50:01 PAGE 2   

  49   1          value=0xffff-pwm;
  50   1          TR0 = 0;
  51   1          TL0=value;                  //16位数据给8位数据赋值默认将16位数据的低八位直接赋给八位数据
  52   1          TH0=value>>8;               //将16位数据右移8位，也就是将高8位移到低八位，再赋值给8位数
             -
  53   1          TR0 = 1;
  54   1      }
  55          
  56          /***********************************************************
  57          * 名    称： Timer0_isr() interrupt 1 using 1
  58          * 功    能： 时钟0中断处理
  59          * 入口参数： 无
  60          * 出口参数： 无
  61          * 说    明：
  62          /**********************************************************/
  63          void Timer0_isr(void) interrupt 1 using 1
  64          {
  65   1          static unsigned char i = 1; //静态变量：每次调用函数时保持上一次所赋的值，
  66   1          //跟全局变量类似，不同是它只能用于此函数内部
  67   1          switch(i)
  68   1          {
  69   2          case 1:
  70   2              Car_Servo = 1;  //PWM控制脚高电平
  71   2              //给定时器0赋值，计数Pwm0Duty个脉冲后产生中断，下次中断会进入下一个cas
             -e语句
  72   2              Timer0Value(Servo0PwmDuty);
  73   2              break;
  74   2          case 2:
  75   2              Car_Servo = 0;  //PWM控制脚低电平
  76   2              //高脉冲结束后剩下的时间(20000-Pwm0Duty)全是低电平了，Pwm0Duty + (20000-Pwm0Duty
             -) = 20000个脉冲正好为一个周期20毫秒
  77   2              Timer0Value(20000-Servo0PwmDuty);
  78   2              i = 0;
  79   2              break;
  80   2          }
  81   1          i++;
  82   1      }
  83          
  84          sbit  Car_Motor_A1=P3^2;         // 电机PWM控制端
  85          sbit  Car_Motor_EN1=P3^3;        //电机使能控制端
  86          sbit  Car_Motor_B1=P3^4;         // 电机控制端
  87          
  88          unsigned int Motor0PwmDuty=2750;                  //初始占空比为3000:7000
  89          unsigned int Motor0PwmDuty_daoche=2750;
  90          /***********************************************************
  91          * 名    称：Timer1Value(unsigned int pwm)
  92          * 功    能：给定时器1计数器赋值产生定时中断
  93          * 入口参数：pwm            控制电机的PWM脉冲宽度值（范围：0~10000）
  94          * 出口参数：无
  95          * 说    明：12M晶振，12分频，所以计数器每递增一个数就是1微秒，完全满足舵机
             -制的精度要求
  96                                  因为定时器是TH0，TL0都要全部计数到0xFF后在计1个数就会产生中断，所以要想
             -生
  97                                  pwm毫秒的中断，那么TH0，TL0就应该赋值（0xFFFF-pwm）     从这个值开始计数产生定
             -中断
  98          /**********************************************************/
  99          void Timer1Value(unsigned int pwm)
 100          {
 101   1          unsigned int value;
 102   1          value=0xffff-pwm;
 103   1          TR1 = 0;
 104   1          TL1=value;                  //16位数据给8位数据赋值默认将16位数据的低八位直接赋给八位数据
C51 COMPILER V9.54   MAIN                                                                  09/21/2022 10:50:01 PAGE 3   

 105   1          TH1=value>>8;               //将16位数据右移8位，也就是将高8位移到低八位，再赋值给8位数
             -
 106   1          TR1 = 1;
 107   1      }
 108          
 109          /***********************************************************
 110          * 名    称：Timer1Init
 111          * 功    能：电机时钟1初始化
 112          * 入口参数：无
 113          * 出口参数：无
 114          * 说    明：10ms一周期
 115          /**********************************************************/
 116          void Timer1Init(void)           //10毫秒@12.000MHz
 117          {
 118   1          TMOD &= 0x0F;               //设置定时器模式
 119   1          TMOD |= 0x10;               //设置定时器模式
 120   1          TL1 = 0xF0;                 //设置定时初值
 121   1          TH1 = 0xD8;                 //设置定时初值
 122   1          TF1 = 0;                    //清除TF1标志
 123   1          TR1 = 1;                    //定时器1开始计时
 124   1          ET1 = 1;                    //开定时器1中断
 125   1          EA = 1;             //开总中断
 126   1      }
 127          
 128          /***********************************************************
 129          * 名    称：Car_Motor_Init()
 130          * 功    能：电机初始化
 131          * 入口参数：无
 132          * 出口参数：无
 133          * 说    明：10ms一周期
 134          /**********************************************************/
 135          void Car_Motor_Init()
 136          {
 137   1          Car_Motor_EN1=1;     //电机使能控制端
 138   1          Car_Motor_B1=0;      // 电机控制端一端为低
 139   1          Car_Motor_A1=0;      // 电机PWM控制端一端为低
 140   1          Timer1Init();       //电机定时器初始化
 141   1      }
 142          /***********************************************************
 143          * 名    称： Timer1_isr() interrupt 3 using 3
 144          * 功    能： 时钟0中断处理
 145          * 入口参数： 无
 146          * 出口参数： 无
 147          * 说    明：i变量是轨道丢失的统计参数，根据i的计数量判断已经丢失轨道多久
 148                                  其中程序是指5000个命令周期后执行倒车的计时器内容
 149          /**********************************************************/
 150          void Timer1_isr(void) interrupt 3 using 3
 151          {
 152   1          static unsigned char j = 1; //静态变量：每次调用函数时保持上一次所赋的值，
 153   1          //跟全局变量类似，不同是它只能用于此函数内部
 154   1          if(i<5000)//左侧参数就是判断丢失的时间，丢失判断防抖
 155   1          {
 156   2              switch(j)
 157   2              {
 158   3              case 1:
 159   3                  Car_Motor_A1 = 1;   //PWM控制脚高电平
 160   3                  //给定时器0赋值，计数Pwm0Duty个脉冲后产生中断，下次中断会进入下一
             -case语句
 161   3      
 162   3                  Timer1Value(Motor0PwmDuty); //高电平持续时间
 163   3                  break;
 164   3              case 2:
C51 COMPILER V9.54   MAIN                                                                  09/21/2022 10:50:01 PAGE 4   

 165   3                  Car_Motor_A1 = 0;   //PWM控制脚低电平
 166   3                  //高脉冲结束后剩下的时间(20000-Pwm0Duty)全是低电平了，Pwm0Duty + (20000-Pwm0
             -Duty) = 20000个脉冲正好为一个周期20毫秒
 167   3                  Timer1Value(10000-Motor0PwmDuty);//低电平持续时间
 168   3                  j = 0;
 169   3                  break;
 170   3              }
 171   2              j++;
 172   2          }
 173   1          else
 174   1          {
 175   2              switch(j)
 176   2              {
 177   3              case 1:
 178   3                  Car_Motor_B1 = 1;   //PWM控制脚高电平
 179   3                  //给定时器0赋值，计数Pwm0Duty个脉冲后产生中断，下次中断会进入下一
             -case语句
 180   3      
 181   3                  Timer1Value(Motor0PwmDuty_daoche);  //高电平持续时间
 182   3                  break;
 183   3              case 2:
 184   3                  Car_Motor_B1 = 0;   //PWM控制脚低电平
 185   3                  //高脉冲结束后剩下的时间(20000-Pwm0Duty)全是低电平了，Pwm0Duty + (20000-Pwm0
             -Duty) = 20000个脉冲正好为一个周期20毫秒
 186   3                  Timer1Value(10000-Motor0PwmDuty_daoche);
 187   3                  j = 0;
 188   3                  break;
 189   3              }
 190   2              j++;
 191   2          }
 192   1      
 193   1      }
 194          /***********************************************************
 195          * 名    称：ctry()
 196          * 功    能：轨道位置的判断
 197          * 入口参数：P0 P2^3
 198          * 出口参数：输出轨道变量path，该参数为环境变量，舵机的中断处理
 199                                  会因为path的改变而选择合适的角度
 200          * 说    明：i++就是对轨道偏离的统计
 201          /**********************************************************/
 202          sbit AB=P2^3; // 舵机转向的标记端口
 203          int ctry(unsigned int parameter)
 204          {
 205   1          if(AB==1)
 206   1          {
 207   2              switch(parameter)
 208   2                      {
 209   3                      case 199:
 210   3                  i=0;
 211   3                  return 2166;
 212   3              case 223:
 213   3                  i=0;
 214   3                  return 2000;
 215   3              case 239:
 216   3                  i=0;
 217   3                  return 1800;
 218   3              case 247:
 219   3                  i=0;
 220   3                  return 1500;//90°
 221   3              case 251:
 222   3                  i=0;
 223   3                  return 1200;
C51 COMPILER V9.54   MAIN                                                                  09/21/2022 10:50:01 PAGE 5   

 224   3              case 253:
 225   3                  i=0;
 226   3                  return 1000;
 227   3              case 254:
 228   3                  i=0;
 229   3                  return 833;//30°
 230   3              case 255:
 231   3                  i++;
 232   3                  return 1500;//检测无轨道就让车头对正帮助倒车
 233   3              default:
 234   3                  return Servo0PwmDuty;
 235   3                      }
 236   2          }
 237   1          else
 238   1          {
 239   2              switch(parameter)
 240   2              {
 241   3              case 191:
 242   3                  i=0;
 243   3                  return 833;//30°
 244   3              case 223:
 245   3                  i=0;
 246   3                  return 1000;
 247   3              case 239:
 248   3                  i=0;
 249   3                  return 1200;
 250   3              case 247:
 251   3                  i=0;
 252   3                  return 1500;//90°
 253   3              case 251:
 254   3                  i=0;
 255   3                  return 1800;
 256   3              case 253:
 257   3                  i=0;
 258   3                  return 2000;
 259   3              case 254:
 260   3                  i=0;
 261   3                  return 2166;
 262   3              case 255:
 263   3                  i++;
 264   3                  return 1500;//检测无轨道就让车头对正帮助倒车
 265   3              default:
 266   3                  return Servo0PwmDuty;
 267   3              }
 268   2          }
 269   1      
 270   1      }
 271          sbit LEDA=P2^1;//刹车灯的IO接口
 272          sbit LEDB=P2^2;//刹车灯的IO接口
 273          /***********************************************************
 274          * 名    称：daoche()
 275          * 功    能：倒车指示以及对倒车状态的清零
 276          * 入口参数：无
 277          * 出口参数：无
 278          * 说    明：检测到丢失后又执行10000个命令周期的倒车，无论是否
 279                                  重新寻找到路径都前进一段，重新巡线反复扫描，保证成功率
 280          /**********************************************************/
 281          void daoche()
 282          {
 283   1          if(i>5000)          //轨道丢失防抖
 284   1          {   LEDA = 1;
 285   2              LEDB = 0;
C51 COMPILER V9.54   MAIN                                                                  09/21/2022 10:50:01 PAGE 6   

 286   2              if(i>15000)//倒车持续的检测周期
 287   2              {
 288   3                  i=0;//丢失标记清楚
 289   3              }
 290   2          }
 291   1      
 292   1          else
 293   1          {   LEDA = 0;
 294   2              LEDB = 0;
 295   2          }
 296   1      }
 297          void main()
 298          {
 299   1          Car_Servo_Init();
 300   1          Car_Motor_Init();
 301   1      
 302   1          while(1)
 303   1          {
 304   2              pow=P1;
 305   2              path=P0;
 306   2              Servo0PwmDuty=ctry(path);
 307   2              Motor0PwmDuty=30*(pow);
 308   2              Motor0PwmDuty_daoche=30*(pow);
 309   2              daoche();
 310   2          }
 311   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    528    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     14       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
