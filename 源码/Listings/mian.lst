C51 COMPILER V9.54   MIAN                                                                  09/20/2022 14:36:00 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MIAN
OBJECT MODULE PLACED IN .\Objects\mian.obj
COMPILER INVOKED BY: D:\filegame\keil\C51\BIN\C51.EXE mian.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\mian.lst) OBJECT(.\Objects\mian.obj)

line level    source

   1          /************代码说明****************/
   2          /*
   3          -本代码为电信科协嵌入式2022年编写的寻迹车代码
   4          -更新说明：
   5                           -1.优化了路径判断的速度，改为使用switch的选择模式
   6                            由之前的条件判断改为了数值判断。
   7          
   8                           -2.舵机转向不可调，在程序内定为了30°~150°，如需
   9                            更改转向角度请计算周期后直接在ctry函数内修改返回
  10                            的高电平时间，相关知识请自行补充PWM的舵机控制。
  11          
  12                           -3.增加了倒车巡线的功能，在丢失路径后，经过“防抖
  13                            判断后”车辆会车头回正，倒车两个防抖周期的时间，
  14                            然后前进一个防抖周期的时间，以此往复直到重新选线
  15                            后继续前进。
  16          
  17                           -4.程序分为A、B两个版本，主要为了应对感应板的线序
  18                            可能出现凌乱。
  19          
  20                           -5.对于感应板的判断要求更高，请尽可能校准感应板的
  21                            基准电压。程序内对于非预定情况的判断是统一回正，
  22                            所以当你将车悬空时车头是不会动的。只有符合仅一个
  23                            灯亮时才会有舵机动作。
  24          
  25                           -6.取消了干簧管的启动功能。
  26          
  27                           -7.电机速度的由编码器控制，接通的数量越多，车越慢
  28                            编码器数值为其对应的二进制码值。（简单理解为推上
  29                            去的越多车越慢，拉下来的越多车越快，越往右权重越
  30                            大）
  31                                                                                  2022-09-xx
  32          更新后如有问题请联系QQ：2605944232 请备注来意
  33          
  34          */
  35          #include "reg52.h"
  36          #include "intrins.h"
  37          /********以下为参数与环境变量区********/
  38          unsigned int path;                                      //红外对管反馈的环境变量
  39          unsigned int pow;                                       //电机驱动力度的调节
  40          unsigned int i=0;                                       //轨道丢失参数(当轨道丢失到一定的时间后启动倒车程序)
  41          sbit  Car_Servo=P2^0;               // 舵机pwm控制
  42          
  43          unsigned int Servo0PwmDuty=1500;        //PWM脉冲宽度   1.5ms脉冲宽度  为舵机正中位置
  44          
  45          /***********************************************************
  46          * 名    称：InitTimer0()
  47          * 功    能：舵机时钟0初始化
  48          * 入口参数：无
  49          * 出口参数：无
  50          * 说    明：12M晶振，12分频，所以计数器每递增一个数就是1微秒，完全满足舵机
             -制的精度要求
  51                                  因为定时器是TH0，TL0都要全部计数到0xFF后在计1个数就会产生中断，所以要想
             -生
  52                                  x毫秒的中断，那么TH0，TL0就应该赋值（0xFFFF-x） 从这个值开始计数产生定时中
C51 COMPILER V9.54   MIAN                                                                  09/20/2022 14:36:00 PAGE 2   

             -断
  53          /**********************************************************/
  54          void InitTimer0(void)           //20ms
  55          {
  56   1          TMOD &= 0xF0;               //设置定时器模式
  57   1          TMOD |= 0x01;               //设置定时器模式
  58   1          TL0 = 0xE0;                 //设置定时初值
  59   1          TH0 = 0xB1;                 //设置定时初值
  60   1          TF0 = 0;                    //清除TF0标志
  61   1          TR0 = 1;                    //定时器0开始计时
  62   1          ET0 = 1;                    //开定时器0中断
  63   1          EA = 1;             //开总中断
  64   1      }
  65          void Car_Servo_Init()   //舵机初始化
  66          {
  67   1          InitTimer0();
  68   1      }
  69          
  70          /***********************************************************
  71          * 名    称：Timer0Value(uint16 pwm)
  72          * 功    能：给定时器0计数器赋值产生定时中断
  73          * 入口参数：pwm            控制舵机的PWM脉冲宽度值（范围：500~2500）
  74          * 出口参数：无
  75          * 说    明：12M晶振，12分频，所以计数器每递增一个数就是1微秒，完全满足舵机
             -制的精度要求
  76                                  因为定时器是TH0，TL0都要全部计数到0xFF后在计1个数就会产生中断，所以要想
             -生
  77                                  pwm毫秒的中断，那么TH0，TL0就应该赋值（0xFFFF-pwm）     从这个值开始计数产生定
             -中断
  78          /**********************************************************/
  79          void Timer0Value(unsigned int pwm)
  80          {
  81   1          unsigned int value;
  82   1          value=0xffff-pwm;
  83   1          TR0 = 0;
  84   1          TL0=value;                  //16位数据给8位数据赋值默认将16位数据的低八位直接赋给八位数据
  85   1          TH0=value>>8;               //将16位数据右移8位，也就是将高8位移到低八位，再赋值给8位数
             -
  86   1          TR0 = 1;
  87   1      }
  88          
  89          /***********************************************************
  90          * 名    称： Timer0_isr() interrupt 1 using 1
  91          * 功    能： 时钟0中断处理
  92          * 入口参数： 无
  93          * 出口参数： 无
  94          * 说    明：
  95          /**********************************************************/
  96          void Timer0_isr(void) interrupt 1 using 1
  97          {
  98   1          static unsigned char i = 1; //静态变量：每次调用函数时保持上一次所赋的值，
  99   1          //跟全局变量类似，不同是它只能用于此函数内部
 100   1          switch(i)
 101   1          {
 102   2          case 1:
 103   2              Car_Servo = 1;  //PWM控制脚高电平
 104   2              //给定时器0赋值，计数Pwm0Duty个脉冲后产生中断，下次中断会进入下一个cas
             -e语句
 105   2              Timer0Value(Servo0PwmDuty);
 106   2              break;
 107   2          case 2:
 108   2              Car_Servo = 0;  //PWM控制脚低电平
C51 COMPILER V9.54   MIAN                                                                  09/20/2022 14:36:00 PAGE 3   

 109   2              //高脉冲结束后剩下的时间(20000-Pwm0Duty)全是低电平了，Pwm0Duty + (20000-Pwm0Duty
             -) = 20000个脉冲正好为一个周期20毫秒
 110   2              Timer0Value(20000-Servo0PwmDuty);
 111   2              i = 0;
 112   2              break;
 113   2          }
 114   1          i++;
 115   1      }
 116          
 117          sbit  Car_Motor_A1=P3^2;         // 电机PWM控制端
 118          sbit  Car_Motor_EN1=P3^3;        //电机使能控制端
 119          sbit  Car_Motor_B1=P3^4;         // 电机控制端
 120          
 121          unsigned int Motor0PwmDuty=2750;                  //初始占空比为3000:7000
 122          unsigned int Motor0PwmDuty_daoche=2750;
 123          /***********************************************************
 124          * 名    称：Timer1Value(unsigned int pwm)
 125          * 功    能：给定时器1计数器赋值产生定时中断
 126          * 入口参数：pwm            控制电机的PWM脉冲宽度值（范围：0~10000）
 127          * 出口参数：无
 128          * 说    明：12M晶振，12分频，所以计数器每递增一个数就是1微秒，完全满足舵机
             -制的精度要求
 129                                  因为定时器是TH0，TL0都要全部计数到0xFF后在计1个数就会产生中断，所以要想
             -生
 130                                  pwm毫秒的中断，那么TH0，TL0就应该赋值（0xFFFF-pwm）     从这个值开始计数产生定
             -中断
 131          /**********************************************************/
 132          void Timer1Value(unsigned int pwm)
 133          {
 134   1          unsigned int value;
 135   1          value=0xffff-pwm;
 136   1          TR1 = 0;
 137   1          TL1=value;                  //16位数据给8位数据赋值默认将16位数据的低八位直接赋给八位数据
 138   1          TH1=value>>8;               //将16位数据右移8位，也就是将高8位移到低八位，再赋值给8位数
             -
 139   1          TR1 = 1;
 140   1      }
 141          
 142          /***********************************************************
 143          * 名    称：Timer1Init
 144          * 功    能：电机时钟1初始化
 145          * 入口参数：无
 146          * 出口参数：无
 147          * 说    明：10ms一周期
 148          /**********************************************************/
 149          void Timer1Init(void)           //10毫秒@12.000MHz
 150          {
 151   1          TMOD &= 0x0F;               //设置定时器模式
 152   1          TMOD |= 0x10;               //设置定时器模式
 153   1          TL1 = 0xF0;                 //设置定时初值
 154   1          TH1 = 0xD8;                 //设置定时初值
 155   1          TF1 = 0;                    //清除TF1标志
 156   1          TR1 = 1;                    //定时器1开始计时
 157   1          ET1 = 1;                    //开定时器1中断
 158   1          EA = 1;             //开总中断
 159   1      }
 160          
 161          /***********************************************************
 162          * 名    称：Car_Motor_Init()
 163          * 功    能：电机初始化
 164          * 入口参数：无
 165          * 出口参数：无
C51 COMPILER V9.54   MIAN                                                                  09/20/2022 14:36:00 PAGE 4   

 166          * 说    明：10ms一周期
 167          /**********************************************************/
 168          void Car_Motor_Init()
 169          {
 170   1          Car_Motor_EN1=1;     //电机使能控制端
 171   1          Car_Motor_B1=0;      // 电机控制端一端为低
 172   1          Car_Motor_A1=0;      // 电机PWM控制端一端为低
 173   1          Timer1Init();       //电机定时器初始化
 174   1      }
 175          /***********************************************************
 176          * 名    称： Timer1_isr() interrupt 3 using 3
 177          * 功    能： 时钟0中断处理
 178          * 入口参数： 无
 179          * 出口参数： 无
 180          * 说    明：i变量是轨道丢失的统计参数，根据i的计数量判断已经丢失轨道多久
 181                                  其中程序是指5000个命令周期后执行倒车的计时器内容
 182          /**********************************************************/
 183          void Timer1_isr(void) interrupt 3 using 3
 184          {
 185   1          static unsigned char j = 1; //静态变量：每次调用函数时保持上一次所赋的值，
 186   1          //跟全局变量类似，不同是它只能用于此函数内部
 187   1          if(i<5000)//左侧参数就是判断丢失的时间，丢失判断防抖
 188   1          {
 189   2              switch(j)
 190   2              {
 191   3              case 1:
 192   3                  Car_Motor_A1 = 1;   //PWM控制脚高电平
 193   3                  //给定时器0赋值，计数Pwm0Duty个脉冲后产生中断，下次中断会进入下一
             -case语句
 194   3      
 195   3                  Timer1Value(Motor0PwmDuty); //高电平持续时间
 196   3                  break;
 197   3              case 2:
 198   3                  Car_Motor_A1 = 0;   //PWM控制脚低电平
 199   3                  //高脉冲结束后剩下的时间(20000-Pwm0Duty)全是低电平了，Pwm0Duty + (20000-Pwm0
             -Duty) = 20000个脉冲正好为一个周期20毫秒
 200   3                  Timer1Value(10000-Motor0PwmDuty);//低电平持续时间
 201   3                  j = 0;
 202   3                  break;
 203   3              }
 204   2              j++;
 205   2          }
 206   1          else
 207   1          {
 208   2              switch(j)
 209   2              {
 210   3              case 1:
 211   3                  Car_Motor_B1 = 1;   //PWM控制脚高电平
 212   3                  //给定时器0赋值，计数Pwm0Duty个脉冲后产生中断，下次中断会进入下一
             -case语句
 213   3      
 214   3                  Timer1Value(Motor0PwmDuty_daoche);  //高电平持续时间
 215   3                  break;
 216   3              case 2:
 217   3                  Car_Motor_B1 = 0;   //PWM控制脚低电平
 218   3                  //高脉冲结束后剩下的时间(20000-Pwm0Duty)全是低电平了，Pwm0Duty + (20000-Pwm0
             -Duty) = 20000个脉冲正好为一个周期20毫秒
 219   3                  Timer1Value(10000-Motor0PwmDuty_daoche);
 220   3                  j = 0;
 221   3                  break;
 222   3              }
 223   2              j++;
C51 COMPILER V9.54   MIAN                                                                  09/20/2022 14:36:00 PAGE 5   

 224   2          }
 225   1      
 226   1      }
 227          /***********************************************************
 228          * 名    称：ctry()
 229          * 功    能：轨道位置的判断
 230          * 入口参数：P0
 231          * 出口参数：输出轨道变量path，该参数为环境变量，舵机的中断处理
 232                                  会因为path的改变而选择合适的角度
 233          * 说    明：i++就是对轨道偏离的统计
 234          /**********************************************************/
 235          sbit AB=P2^3;
 236          int ctry(unsigned int parameter)
 237          {
 238   1          if(AB==1)
 239   1          {
 240   2              switch(parameter)
 241   2              {
 242   3              case 191:
 243   3                  i=0;
 244   3                  return 2166;
 245   3              case 223:
 246   3                  i=0;
 247   3                  return 2000;
 248   3              case 239:
 249   3                  i=0;
 250   3                  return 1800;
 251   3              case 247:
 252   3                  i=0;
 253   3                  return 1500;//90°
 254   3              case 251:
 255   3                  i=0;
 256   3                  return 1200;
 257   3              case 253:
 258   3                  i=0;
 259   3                  return 1000;
 260   3              case 254:
 261   3                  i=0;
 262   3                  return 833;//30°
 263   3              case 255:
 264   3                  i++;
 265   3                  return 1500;//检测无轨道就让车头对正帮助倒车
 266   3              default:
 267   3                  return Servo0PwmDuty;
 268   3              }
 269   2          }
 270   1          else
 271   1          {
 272   2              switch(parameter)
 273   2              {
 274   3              case 191:
 275   3                  i=0;
 276   3                  return 833;
 277   3              case 223:
 278   3                  i=0;
 279   3                  return 1000;
 280   3              case 239:
 281   3                  i=0;
 282   3                  return 1200;
 283   3              case 247:
 284   3                  i=0;
 285   3                  return 1500;//90°
C51 COMPILER V9.54   MIAN                                                                  09/20/2022 14:36:00 PAGE 6   

 286   3              case 251:
 287   3                  i=0;
 288   3                  return 1800;
 289   3              case 253:
 290   3                  i=0;
 291   3                  return 2000;
 292   3              case 254:
 293   3                  i=0;
 294   3                  return 2166;
 295   3              case 255:
 296   3                  i++;
 297   3                  return 1500;//检测无轨道就让车头对正帮助倒车
 298   3              default:
 299   3                  return Servo0PwmDuty;
 300   3              }
 301   2          }
 302   1      
 303   1      }
 304          sbit LEDA=P2^1;//刹车灯的IO接口
 305          sbit LEDB=P2^2;//刹车灯的IO接口
 306          /***********************************************************
 307          * 名    称：daoche()
 308          * 功    能：倒车指示以及对倒车状态的清零
 309          * 入口参数：无
 310          * 出口参数：无
 311          * 说    明：检测到丢失后又执行10000个命令周期的倒车，无论是否
 312                                  重新寻找到路径都前进一段，重新巡线反复扫描，保证成功率
 313          /**********************************************************/
 314          void daoche()
 315          {
 316   1          if(i>5000)          //轨道丢失防抖
 317   1          {   LEDA = 1;
 318   2              LEDB = 0;
 319   2              if(i>15000)//倒车持续的检测周期
 320   2              {
 321   3                  i=0;
 322   3              }
 323   2          }
 324   1      
 325   1          else
 326   1          {   LEDA = 0;
 327   2              LEDB = 0;
 328   2          }
 329   1      }
 330          void main()
 331          {
 332   1          Car_Servo_Init();
 333   1          Car_Motor_Init();
 334   1      
 335   1          while(1)
 336   1          {
 337   2              pow=P1;
 338   2              path=P0;
 339   2              Servo0PwmDuty=ctry(path);
 340   2              Motor0PwmDuty=30*pow;
 341   2              Motor0PwmDuty_daoche=30*pow;
 342   2              daoche();
 343   2          }
 344   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.54   MIAN                                                                  09/20/2022 14:36:00 PAGE 7   

   CODE SIZE        =    528    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     14       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
